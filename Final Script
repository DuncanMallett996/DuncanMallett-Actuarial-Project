# ==========================================================
# GROUP COURSEWORK 3 – TERM ASSURANCE
# ==========================================================
# Implements:
# Part A – Detect errors
# Part B – Maintain policyholders
# Part C – Summarise premiums, death benefits and individual policies
# Part D – Simulate deaths

# ==========================================================
# Helper functions
# ==========================================================
# Removes leading/trailing spaces and handles NA values
.trim_or_blank <- function(x) {
  if (is.na(x)) return("")
  trimws(as.character(x))
}

# Ensures output folder exists before writing files
.ensure_dir <- function(path) {
  dir.create(path, recursive = TRUE, showWarnings = FALSE)
}

# Cleans column names (removes accidental spaces)
.clean_colnames <- function(df) {
  names(df) <- trimws(names(df))
  df
}
# ==========================================================
# Part A – Detect Errors
# ==========================================================
# Reads the RAW file and writes an error report to output/
# The report makes it easy to see which policy and which field is wrong.

detect.errors <- function(raw_file = "data/pholdersraw.csv",
                          output_file = "output/error_report.csv",
                          data_year = 2026) {
  
  raw <- read.csv(raw_file, stringsAsFactors = FALSE)
  raw <- .clean_colnames(raw)
  
  errors <- data.frame(
    policy.number = character(),
    field = character(),
    error.description = character(),
    current.value = character(),
    stringsAsFactors = FALSE
  )
  
  add.error <- function(errors_df, policy, field, description, value) {
    rbind(errors_df,
          data.frame(policy.number = policy,
                     field = field,
                     error.description = description,
                     current.value = as.character(value),
                     stringsAsFactors = FALSE))
  }
  
  valid.sexes  <- c("Male", "Female")
  valid.smoker <- c("Non-smoker", "Smoker", "Ex-smoker")
  valid.exits  <- c("Death", "Withdrawl", "End", "")
  
  required_fields <- c(
    "policy.number", "first.name", "surname",
    "inception.year", "age.at.inception", "premium",
    "sum.assured", "term", "sex", "smoker.status"
  )
  
  for (i in seq_len(nrow(raw))) {
    
    pol <- raw$policy.number[i]
    
    # Check required fields are not blank
    for (field in required_fields) {
      val <- raw[[field]][i]
      if (is.na(val) || .trim_or_blank(val) == "") {
        errors <- add.error(errors, pol, field,
                            paste("Required field", field, "is blank/missing"),
                            "NA/Blank")
      }
    }
    
    age <- raw$age.at.inception[i]
    term <- raw$term[i]
    inc_year <- raw$inception.year[i]
    sex <- raw$sex[i]
    smoker <- raw$smoker.status[i]
    exit_val <- raw$exit[i]
    exit_str <- .trim_or_blank(exit_val)
    year_of_exit <- raw$year.of.exit[i]
    
    # Age must be between 65 and 75
    if (!is.na(age) && (age < 65 || age > 75)) {
      errors <- add.error(errors, pol, "age.at.inception",
                          "Age must be between 65 and 75",
                          age)
    }
    
    # Policy must not extend beyond age 90
    if (!is.na(age) && !is.na(term) && (age + term > 90)) {
      errors <- add.error(errors, pol, "term",
                          "Term takes policyholder beyond age 90",
                          term)
    }
    
    # Inception year cannot be in the future
    if (!is.na(inc_year) && inc_year > data_year) {
      errors <- add.error(errors, pol, "inception.year",
                          "Inception year is after the data year",
                          inc_year)
    }
    
    # Sex must be valid
    if (!is.na(sex) && !(sex %in% valid.sexes)) {
      errors <- add.error(errors, pol, "sex",
                          "Invalid sex value",
                          sex)
    }
    
    # Smoker status must be valid
    if (!is.na(smoker) && !(smoker %in% valid.smoker)) {
      errors <- add.error(errors, pol, "smoker.status",
                          "Invalid smoker status",
                          smoker)
    }
    
    # Exit must be valid (blank is allowed for active)
    if (!(exit_str %in% valid.exits)) {
      errors <- add.error(errors, pol, "exit",
                          "Invalid exit value",
                          exit_str)
    }
    
    # Exit cannot happen in data_year or later (data is at the start of data_year)
    if (!is.na(year_of_exit) && year_of_exit >= data_year && exit_str != "") {
      errors <- add.error(errors, pol, "year.of.exit",
                          "Exit recorded in data year or later",
                          year_of_exit)
    }
  }
  
  .ensure_dir(dirname(output_file))
  write.csv(errors, output_file, row.names = FALSE)
  
  cat("Part A complete – Error report written to:", output_file, "\n")
  cat("Total errors found:", nrow(errors), "\n")
  return(errors)
}

# ==========================================================
# Part B – Maintaining Policyholders (updates pholders.csv)
# ==========================================================
# These functions edit data/pholders.csv. In a real workflow:
#   Add new business at the start of the year
#   Record deaths (assumed mid-year)
#   Record withdrawals (assumed end of year)
#   Mark any policies that naturally reach end of term

add.member <- function(policy_number, first_name, surname,
                       inception_year, age, premium,
                       sum_assured, term, sex, smoker_status,
                       data_file = "data/pholders.csv") {
  
  # Simple checks to prevent invalid policies being added
  if (age < 65 || age > 75) {
    cat("ERROR: age must be between 65 and 75.\n")
    return(FALSE)
  }
  if (term <= 0) {
    cat("ERROR: term must be positive.\n")
    return(FALSE)
  }
  if (age + term > 90) {
    cat("ERROR: term takes policyholder beyond age 90.\n")
    return(FALSE)
  }
  if (premium <= 0 || sum_assured <= 0) {
    cat("ERROR: premium and sum assured must be positive.\n")
    return(FALSE)
  }
  if (!(sex %in% c("Male", "Female"))) {
    cat("ERROR: sex must be Male or Female.\n")
    return(FALSE)
  }
  if (!(smoker_status %in% c("Non-smoker", "Smoker", "Ex-smoker"))) {
    cat("ERROR: smoker status must be Non-smoker, Smoker, or Ex-smoker.\n")
    return(FALSE)
  }
  
  ph <- read.csv(data_file, stringsAsFactors = FALSE)
  ph <- .clean_colnames(ph)
  
  # Prevent duplicate policy numbers
  if (policy_number %in% ph$policy.number) {
    cat("ERROR: policy number already exists.\n")
    return(FALSE)
  }
  
  # New policy starts with no exit recorded
  new_row <- data.frame(
    policy.number = policy_number,
    first.name = first_name,
    surname = surname,
    inception.year = inception_year,
    age.at.inception = age,
    premium = premium,
    sum.assured = sum_assured,
    term = term,
    sex = sex,
    smoker.status = smoker_status,
    exit = NA,
    year.of.exit = NA,
    stringsAsFactors = FALSE
  )
  
  ph <- rbind(ph, new_row)
  write.csv(ph, data_file, row.names = FALSE)
  cat("Added new policy:", policy_number, "\n")
  return(TRUE)
}


record.deaths <- function(policy_numbers, year,
                          data_file = "data/pholders.csv") {
  
  ph <- read.csv(data_file, stringsAsFactors = FALSE)
  ph <- .clean_colnames(ph)
  
  # Loop through each requested policy number
  for (pol in policy_numbers) {
    
    # Only record death if the policy exists AND is still active (no exit yet)
    idx <- which(ph$policy.number == pol &
                   (is.na(ph$exit) | .trim_or_blank(ph$exit) == ""))
    
    if (length(idx) == 0) {
      cat("WARNING: could not record death for", pol, "(not found or already exited)\n")
      next
    }
    
    # Update exit information
    ph$exit[idx] <- "Death"
    ph$year.of.exit[idx] <- year
    cat("Recorded death:", pol, "in", year, "\n")
  }
  
  write.csv(ph, data_file, row.names = FALSE)
}


record.withdrawals <- function(policy_numbers, year,
                               data_file = "data/pholders.csv") {
  
  ph <- read.csv(data_file, stringsAsFactors = FALSE)
  ph <- .clean_colnames(ph)
  
  # Withdrawals are assumed to happen at the end of the year,
  # so we only allow withdrawal if the policy is currently active.
  for (pol in policy_numbers) {
    
    idx <- which(ph$policy.number == pol &
                   (is.na(ph$exit) | .trim_or_blank(ph$exit) == ""))
    
    if (length(idx) == 0) {
      cat("WARNING: could not record withdrawal for", pol, "(not found or already exited)\n")
      next
    }
    
    ph$exit[idx] <- "Withdrawl"
    ph$year.of.exit[idx] <- year
    cat("Recorded withdrawal:", pol, "in", year, "\n")
  }
  
  write.csv(ph, data_file, row.names = FALSE)
}


check.end.of.term <- function(year,
                              data_file = "data/pholders.csv") {
  
  ph <- read.csv(data_file, stringsAsFactors = FALSE)
  ph <- .clean_colnames(ph)
  
  ended <- character(0)
  
  # Check each active policy: if it has reached the end of term, mark exit = End
  for (i in seq_len(nrow(ph))) {
    
    is_active <- is.na(ph$exit[i]) || .trim_or_blank(ph$exit[i]) == ""
    if (!is_active) next
    
    last_cover_year <- ph$inception.year[i] + ph$term[i] - 1
    
    if (year >= last_cover_year) {
      ph$exit[i] <- "End"
      ph$year.of.exit[i] <- last_cover_year
      ended <- c(ended, ph$policy.number[i])
      cat("Policy ended:", ph$policy.number[i], "in", last_cover_year, "\n")
    }
  }
  
  write.csv(ph, data_file, row.names = FALSE)
  
  if (length(ended) == 0) cat("No policies reached end of term for", year, "\n")
  return(ended)
}
# ==========================================================
# Part C – Summaries and policy values
# ==========================================================
# Part C is for reporting:
#   - Premiums received in a given year (for policies active at start of year)
#   - Death benefits paid in a given year
#   - Individual policy premium/claim values (nominal + present value)

is.active.at.start <- function(ph, year) {
  
  # Must have started by this year
  if (ph$inception.year > year) return(FALSE)
  
  # Work out last year of cover from inception and term
  last_cover_year <- ph$inception.year + ph$term - 1
  
  # If cover would have ended before this year, not active
  if (year > last_cover_year) return(FALSE)
  
  # If no exit recorded, it is active
  if (is.na(ph$exit) || .trim_or_blank(ph$exit) == "") return(TRUE)
  
  # If exit exists, it is still active at the start of 'year' if exit year >= year
  # (death is assumed mid-year; withdrawal/end assumed year-end)
  if (!is.na(ph$year.of.exit) && ph$year.of.exit >= year) return(TRUE)
  
  FALSE
}
