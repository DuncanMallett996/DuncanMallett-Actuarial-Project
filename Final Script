# ==========================================================
# GROUP COURSEWORK 3 – TERM ASSURANCE
# ==========================================================
# Implements:
# Part A – Detect errors
# Part B – Maintain policyholders
# Part C – Summarise premiums, death benefits and individual policies
# Part D – Simulate deaths

# ==========================================================
# Helper functions
# ==========================================================
# Removes leading/trailing spaces and handles NA values
.trim_or_blank <- function(x) {
  if (is.na(x)) return("")
  trimws(as.character(x))
}

# Ensures output folder exists before writing files
.ensure_dir <- function(path) {
  dir.create(path, recursive = TRUE, showWarnings = FALSE)
}

# Cleans column names (removes accidental spaces)
.clean_colnames <- function(df) {
  names(df) <- trimws(names(df))
  df
}
# ==========================================================
# Part A – Detect Errors
# ==========================================================
# Reads the RAW file and writes an error report to output/
# The report makes it easy to see which policy and which field is wrong.

detect.errors <- function(raw_file = "data/pholdersraw.csv",
                          output_file = "output/error_report.csv",
                          data_year = 2026) {
  
  raw <- read.csv(raw_file, stringsAsFactors = FALSE)
  raw <- .clean_colnames(raw)
  
  errors <- data.frame(
    policy.number = character(),
    field = character(),
    error.description = character(),
    current.value = character(),
    stringsAsFactors = FALSE
  )
  
  add.error <- function(errors_df, policy, field, description, value) {
    rbind(errors_df,
          data.frame(policy.number = policy,
                     field = field,
                     error.description = description,
                     current.value = as.character(value),
                     stringsAsFactors = FALSE))
  }
  
  valid.sexes  <- c("Male", "Female")
  valid.smoker <- c("Non-smoker", "Smoker", "Ex-smoker")
  valid.exits  <- c("Death", "Withdrawl", "End", "")
  
  required_fields <- c(
    "policy.number", "first.name", "surname",
    "inception.year", "age.at.inception", "premium",
    "sum.assured", "term", "sex", "smoker.status"
  )
  
  for (i in seq_len(nrow(raw))) {
    
    pol <- raw$policy.number[i]
    
    # Check required fields are not blank
    for (field in required_fields) {
      val <- raw[[field]][i]
      if (is.na(val) || .trim_or_blank(val) == "") {
        errors <- add.error(errors, pol, field,
                            paste("Required field", field, "is blank/missing"),
                            "NA/Blank")
      }
    }
    
    age <- raw$age.at.inception[i]
    term <- raw$term[i]
    inc_year <- raw$inception.year[i]
    sex <- raw$sex[i]
    smoker <- raw$smoker.status[i]
    exit_val <- raw$exit[i]
    exit_str <- .trim_or_blank(exit_val)
    year_of_exit <- raw$year.of.exit[i]
    
    # Age must be between 65 and 75
    if (!is.na(age) && (age < 65 || age > 75)) {
      errors <- add.error(errors, pol, "age.at.inception",
                          "Age must be between 65 and 75",
                          age)
    }
    
    # Policy must not extend beyond age 90
    if (!is.na(age) && !is.na(term) && (age + term > 90)) {
      errors <- add.error(errors, pol, "term",
                          "Term takes policyholder beyond age 90",
                          term)
    }
    
    # Inception year cannot be in the future
    if (!is.na(inc_year) && inc_year > data_year) {
      errors <- add.error(errors, pol, "inception.year",
                          "Inception year is after the data year",
                          inc_year)
    }
    
    # Sex must be valid
    if (!is.na(sex) && !(sex %in% valid.sexes)) {
      errors <- add.error(errors, pol, "sex",
                          "Invalid sex value",
                          sex)
    }
    
    # Smoker status must be valid
    if (!is.na(smoker) && !(smoker %in% valid.smoker)) {
      errors <- add.error(errors, pol, "smoker.status",
                          "Invalid smoker status",
                          smoker)
    }
    
    # Exit must be valid (blank is allowed for active)
    if (!(exit_str %in% valid.exits)) {
      errors <- add.error(errors, pol, "exit",
                          "Invalid exit value",
                          exit_str)
    }
    
    # Exit cannot happen in data_year or later (data is at the start of data_year)
    if (!is.na(year_of_exit) && year_of_exit >= data_year && exit_str != "") {
      errors <- add.error(errors, pol, "year.of.exit",
                          "Exit recorded in data year or later",
                          year_of_exit)
    }
  }
  
  .ensure_dir(dirname(output_file))
  write.csv(errors, output_file, row.names = FALSE)
  
  cat("Part A complete – Error report written to:", output_file, "\n")
  cat("Total errors found:", nrow(errors), "\n")
  return(errors)
}
