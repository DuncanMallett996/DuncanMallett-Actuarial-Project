# ==========================================================
# GROUP COURSEWORK 3 – TERM ASSURANCE
# ==========================================================
# Implements:
# Part A – Detect errors
# Part B – Maintain policyholders
# Part C – Summarise premiums, death benefits and individual policies
# Part D – Simulate deaths

# ==========================================================
# Helper functions
# ==========================================================
# Removes leading/trailing spaces and handles NA values
.trim_or_blank <- function(x) {
  if (is.na(x)) return("")
  trimws(as.character(x))
}

# Ensures output folder exists before writing files
.ensure_dir <- function(path) {
  dir.create(path, recursive = TRUE, showWarnings = FALSE)
}

# Cleans column names (removes accidental spaces)
.clean_colnames <- function(df) {
  names(df) <- trimws(names(df))
  df
}
# ==========================================================
# Part A – Detect Errors
# ==========================================================
# Reads the RAW file and writes an error report to output/
# The report makes it easy to see which policy and which field is wrong.

detect.errors <- function(raw_file = "data/pholdersraw.csv",
                          output_file = "output/error_report.csv",
                          data_year = 2026) {
  
  raw <- read.csv(raw_file, stringsAsFactors = FALSE)
  raw <- .clean_colnames(raw)
  
  errors <- data.frame(
    policy.number = character(),
    field = character(),
    error.description = character(),
    current.value = character(),
    stringsAsFactors = FALSE
  )
  
  add.error <- function(errors_df, policy, field, description, value) {
    rbind(errors_df,
          data.frame(policy.number = policy,
                     field = field,
                     error.description = description,
                     current.value = as.character(value),
                     stringsAsFactors = FALSE))
  }
  
  valid.sexes  <- c("Male", "Female")
  valid.smoker <- c("Non-smoker", "Smoker", "Ex-smoker")
  valid.exits  <- c("Death", "Withdrawl", "End", "")
  
  required_fields <- c(
    "policy.number", "first.name", "surname",
    "inception.year", "age.at.inception", "premium",
    "sum.assured", "term", "sex", "smoker.status"
  )
  
  for (i in seq_len(nrow(raw))) {
    
    pol <- raw$policy.number[i]
    
    # Check required fields are not blank
    for (field in required_fields) {
      val <- raw[[field]][i]
      if (is.na(val) || .trim_or_blank(val) == "") {
        errors <- add.error(errors, pol, field,
                            paste("Required field", field, "is blank/missing"),
                            "NA/Blank")
      }
    }
    
    age <- raw$age.at.inception[i]
    term <- raw$term[i]
    inc_year <- raw$inception.year[i]
    sex <- raw$sex[i]
    smoker <- raw$smoker.status[i]
    exit_val <- raw$exit[i]
    exit_str <- .trim_or_blank(exit_val)
    year_of_exit <- raw$year.of.exit[i]
    
    # Age must be between 65 and 75
    if (!is.na(age) && (age < 65 || age > 75)) {
      errors <- add.error(errors, pol, "age.at.inception",
                          "Age must be between 65 and 75",
                          age)
    }
    
    # Policy must not extend beyond age 90
    if (!is.na(age) && !is.na(term) && (age + term > 90)) {
      errors <- add.error(errors, pol, "term",
                          "Term takes policyholder beyond age 90",
                          term)
    }
    
    # Inception year cannot be in the future
    if (!is.na(inc_year) && inc_year > data_year) {
      errors <- add.error(errors, pol, "inception.year",
                          "Inception year is after the data year",
                          inc_year)
    }
    
    # Sex must be valid
    if (!is.na(sex) && !(sex %in% valid.sexes)) {
      errors <- add.error(errors, pol, "sex",
                          "Invalid sex value",
                          sex)
    }
    
    # Smoker status must be valid
    if (!is.na(smoker) && !(smoker %in% valid.smoker)) {
      errors <- add.error(errors, pol, "smoker.status",
                          "Invalid smoker status",
                          smoker)
    }
    
    # Exit must be valid (blank is allowed for active)
    if (!(exit_str %in% valid.exits)) {
      errors <- add.error(errors, pol, "exit",
                          "Invalid exit value",
                          exit_str)
    }
    
    # Exit cannot happen in data_year or later (data is at the start of data_year)
    if (!is.na(year_of_exit) && year_of_exit >= data_year && exit_str != "") {
      errors <- add.error(errors, pol, "year.of.exit",
                          "Exit recorded in data year or later",
                          year_of_exit)
    }
  }
  
  .ensure_dir(dirname(output_file))
  write.csv(errors, output_file, row.names = FALSE)
  
  cat("Part A complete – Error report written to:", output_file, "\n")
  cat("Total errors found:", nrow(errors), "\n")
  return(errors)
}

# ==========================================================
# Part B – Maintaining Policyholders (updates pholders.csv)
# ==========================================================
# These functions edit data/pholders.csv. In a real workflow:
#   Add new business at the start of the year
#   Record deaths (assumed mid-year)
#   Record withdrawals (assumed end of year)
#   Mark any policies that naturally reach end of term

add.member <- function(policy_number, first_name, surname,
                       inception_year, age, premium,
                       sum_assured, term, sex, smoker_status,
                       data_file = "data/pholders.csv") {
  
  # Simple checks to prevent invalid policies being added
  if (age < 65 || age > 75) {
    cat("ERROR: age must be between 65 and 75.\n")
    return(FALSE)
  }
  if (term <= 0) {
    cat("ERROR: term must be positive.\n")
    return(FALSE)
  }
  if (age + term > 90) {
    cat("ERROR: term takes policyholder beyond age 90.\n")
    return(FALSE)
  }
  if (premium <= 0 || sum_assured <= 0) {
    cat("ERROR: premium and sum assured must be positive.\n")
    return(FALSE)
  }
  if (!(sex %in% c("Male", "Female"))) {
    cat("ERROR: sex must be Male or Female.\n")
    return(FALSE)
  }
  if (!(smoker_status %in% c("Non-smoker", "Smoker", "Ex-smoker"))) {
    cat("ERROR: smoker status must be Non-smoker, Smoker, or Ex-smoker.\n")
    return(FALSE)
  }
  
  ph <- read.csv(data_file, stringsAsFactors = FALSE)
  ph <- .clean_colnames(ph)
  
  # Prevent duplicate policy numbers
  if (policy_number %in% ph$policy.number) {
    cat("ERROR: policy number already exists.\n")
    return(FALSE)
  }
  
  # New policy starts with no exit recorded
  new_row <- data.frame(
    policy.number = policy_number,
    first.name = first_name,
    surname = surname,
    inception.year = inception_year,
    age.at.inception = age,
    premium = premium,
    sum.assured = sum_assured,
    term = term,
    sex = sex,
    smoker.status = smoker_status,
    exit = NA,
    year.of.exit = NA,
    stringsAsFactors = FALSE
  )
  
  ph <- rbind(ph, new_row)
  write.csv(ph, data_file, row.names = FALSE)
  cat("Added new policy:", policy_number, "\n")
  return(TRUE)
}


record.deaths <- function(policy_numbers, year,
                          data_file = "data/pholders.csv") {
  
  ph <- read.csv(data_file, stringsAsFactors = FALSE)
  ph <- .clean_colnames(ph)
  
  # Loop through each requested policy number
  for (pol in policy_numbers) {
    
    # Only record death if the policy exists AND is still active (no exit yet)
    idx <- which(ph$policy.number == pol &
                   (is.na(ph$exit) | .trim_or_blank(ph$exit) == ""))
    
    if (length(idx) == 0) {
      cat("WARNING: could not record death for", pol, "(not found or already exited)\n")
      next
    }
    
    # Update exit information
    ph$exit[idx] <- "Death"
    ph$year.of.exit[idx] <- year
    cat("Recorded death:", pol, "in", year, "\n")
  }
  
  write.csv(ph, data_file, row.names = FALSE)
}


record.withdrawals <- function(policy_numbers, year,
                               data_file = "data/pholders.csv") {
  
  ph <- read.csv(data_file, stringsAsFactors = FALSE)
  ph <- .clean_colnames(ph)
  
  # Withdrawals are assumed to happen at the end of the year,
  # so we only allow withdrawal if the policy is currently active.
  for (pol in policy_numbers) {
    
    idx <- which(ph$policy.number == pol &
                   (is.na(ph$exit) | .trim_or_blank(ph$exit) == ""))
    
    if (length(idx) == 0) {
      cat("WARNING: could not record withdrawal for", pol, "(not found or already exited)\n")
      next
    }
    
    ph$exit[idx] <- "Withdrawl"
    ph$year.of.exit[idx] <- year
    cat("Recorded withdrawal:", pol, "in", year, "\n")
  }
  
  write.csv(ph, data_file, row.names = FALSE)
}


check.end.of.term <- function(year,
                              data_file = "data/pholders.csv") {
  
  ph <- read.csv(data_file, stringsAsFactors = FALSE)
  ph <- .clean_colnames(ph)
  
  ended <- character(0)
  
  # Check each active policy: if it has reached the end of term, mark exit = End
  for (i in seq_len(nrow(ph))) {
    
    is_active <- is.na(ph$exit[i]) || .trim_or_blank(ph$exit[i]) == ""
    if (!is_active) next
    
    last_cover_year <- ph$inception.year[i] + ph$term[i] - 1
    
    if (year >= last_cover_year) {
      ph$exit[i] <- "End"
      ph$year.of.exit[i] <- last_cover_year
      ended <- c(ended, ph$policy.number[i])
      cat("Policy ended:", ph$policy.number[i], "in", last_cover_year, "\n")
    }
  }
  
  write.csv(ph, data_file, row.names = FALSE)
  
  if (length(ended) == 0) cat("No policies reached end of term for", year, "\n")
  return(ended)
}
# ==========================================================
# Part C – Summaries and policy values
# ==========================================================
# Part C is for reporting:
#   - Premiums received in a given year (for policies active at start of year)
#   - Death benefits paid in a given year
#   - Individual policy premium/claim values (nominal + present value)

is.active.at.start <- function(ph, year) {
  
  # Must have started by this year
  if (ph$inception.year > year) return(FALSE)
  
  # Work out last year of cover from inception and term
  last_cover_year <- ph$inception.year + ph$term - 1
  
  # If cover would have ended before this year, not active
  if (year > last_cover_year) return(FALSE)
  
  # If no exit recorded, it is active
  if (is.na(ph$exit) || .trim_or_blank(ph$exit) == "") return(TRUE)
  
  # If exit exists, it is still active at the start of 'year' if exit year >= year
  # (death is assumed mid-year; withdrawal/end assumed year-end)
  if (!is.na(ph$year.of.exit) && ph$year.of.exit >= year) return(TRUE)
  
  FALSE
}
summarise.premiums <- function(year,
                               data_file = "data/pholders.csv") {
  
  ph <- read.csv(data_file, stringsAsFactors = FALSE)
  ph <- .clean_colnames(ph)
  
  # Keep only policies active at the start of the chosen year
  active <- sapply(seq_len(nrow(ph)), function(i) is.active.at.start(ph[i, ], year))
  phA <- ph[active, ]
  
  if (nrow(phA) == 0) {
    cat("No active policies found for year", year, "\n")
    return(NULL)
  }
  
  # Total premiums and breakdowns
  out <- list(
    total = sum(phA$premium),
    by_sex = aggregate(premium ~ sex, phA, sum),
    by_smoker = aggregate(premium ~ smoker.status, phA, sum),
    by_sex_smoker = aggregate(premium ~ sex + smoker.status, phA, sum)
  )
  
  cat("Part C – Premium summary complete for year", year, "\n")
  return(out)
}


summarise.death.benefits <- function(year,
                                     data_file = "data/pholders.csv") {
  
  ph <- read.csv(data_file, stringsAsFactors = FALSE)
  ph <- .clean_colnames(ph)
  
  # Death benefits only include policies that exited by death in this year
  died <- (ph$exit == "Death") & !is.na(ph$year.of.exit) & (ph$year.of.exit == year)
  died[is.na(died)] <- FALSE
  phD <- ph[died, ]
  
  out <- list(
    total = sum(phD$sum.assured),
    by_sex = aggregate(sum.assured ~ sex, phD, sum),
    by_smoker = aggregate(sum.assured ~ smoker.status, phD, sum),
    by_sex_smoker = aggregate(sum.assured ~ sex + smoker.status, phD, sum)
  )
  
  cat("Part C – Death benefit summary complete for year", year, "\n")
  return(out)
}


policy.summary <- function(policy_number, year, rate,
                           data_file = "data/pholders.csv") {
  
  ph <- read.csv(data_file, stringsAsFactors = FALSE)
  ph <- .clean_colnames(ph)
  
  row <- ph[ph$policy.number == policy_number, ]
  if (nrow(row) == 0) {
    cat("ERROR: policy not found:", policy_number, "\n")
    return(NULL)
  }
  
  inc <- row$inception.year
  term <- row$term
  last_cover_year <- inc + term - 1
  
  # Premiums are paid at the start of each year while the policy is in force.
  # If the policy exits (death/withdrawal/end), it is still active at the start of that exit year.
  last_premium_year <- min(year, last_cover_year)
  
  if (!is.na(row$year.of.exit) && .trim_or_blank(row$exit) != "") {
    last_premium_year <- min(last_premium_year, row$year.of.exit)
  }
  
  premium_years <- if (inc <= last_premium_year) inc:last_premium_year else integer(0)
  
  nominal_premium <- length(premium_years) * row$premium
  
  # PV here is the value at end of 'year' (end of year ~ start of year+1)
  pv_premium <- if (length(premium_years) > 0) {
    sum(row$premium * (1 + rate)^(year + 1 - premium_years))
  } else {
    0
  }
  
  # Claim only if death has occurred by the chosen year
  nominal_claim <- 0
  pv_claim <- 0
  
  if (.trim_or_blank(row$exit) == "Death" && !is.na(row$year.of.exit) && row$year.of.exit <= year) {
    nominal_claim <- row$sum.assured
    
    # Death assumed mid-year: half-year timing adjustment
    pv_claim <- row$sum.assured * (1 + rate)^(year - row$year.of.exit + 0.5)
  }
  
  cat("Policy summary produced for", policy_number, "\n")
  
  list(
    nominal_premium = nominal_premium,
    pv_premium = pv_premium,
    nominal_claim = nominal_claim,
    pv_claim = pv_claim
  )
}

# ==========================================================
# Part D – Simulation
# ==========================================================
# Simulates deaths for active policyholders in a chosen year.
# It uses:
#   - mortrates.csv (base mortality by age and sex)
#   - srates.csv    (smoker adjustment factors by sex)
# The result is a table of simulated deaths and their sum assured.

simulate.deaths <- function(year,
                            data_file = "data/pholders.csv",
                            mort_file = "data/mortrates.csv",
                            srates_file = "data/srates.csv",
                            seed = NULL) {
  
  if (!is.null(seed)) set.seed(seed)
  
  ph <- read.csv(data_file, stringsAsFactors = FALSE)
  ph <- .clean_colnames(ph)
  
  mort <- read.csv(mort_file, stringsAsFactors = FALSE)
  mort <- .clean_colnames(mort)
  
  srates <- read.csv(srates_file, stringsAsFactors = FALSE)
  srates <- .clean_colnames(srates)
  
  # Only simulate on policies active at the start of the year
  active <- sapply(seq_len(nrow(ph)), function(i) is.active.at.start(ph[i, ], year))
  phA <- ph[active, ]
  
  if (nrow(phA) == 0) {
    cat("No active policyholders for year", year, "\n")
    return(data.frame())
  }
  
  deaths <- data.frame(
    policy.number = character(),
    sex = character(),
    smoker.status = character(),
    age = integer(),
    mortality.rate = numeric(),
    random.number = numeric(),
    sum.assured = numeric(),
    stringsAsFactors = FALSE
  )
  
  # Loop through each active policyholder and run a simple Monte Carlo death test
  for (i in seq_len(nrow(phA))) {
    
    # Attained age in the simulation year
    age <- phA$age.at.inception[i] + (year - phA$inception.year[i])
    
    # Look up base mortality rate for this age and sex
    mort_row <- which(mort$Age == age)
    if (length(mort_row) == 0) next
    
    base_rate <- if (phA$sex[i] == "Male") mort$Male[mort_row] else mort$Female[mort_row]
    
    # Smoking adjustment factor depends on sex (rows in srates) and smoker status (columns)
    srow <- which(srates$Gender == phA$sex[i])
    if (length(srow) == 0) next
    
    smoke_factor <- if (phA$smoker.status[i] == "Non-smoker") {
      srates$Non.smoker[srow]
    } else if (phA$smoker.status[i] == "Smoker") {
      srates$Smoker[srow]
    } else {
      srates$Ex.Smoker[srow]
    }
    
    # Adjusted death probability for this year
    q <- base_rate * smoke_factor
    
    # Random draw: if U < q, count as a simulated death
    u <- runif(1)
    
    if (u < q) {
      deaths <- rbind(deaths, data.frame(
        policy.number = phA$policy.number[i],
        sex = phA$sex[i],
        smoker.status = phA$smoker.status[i],
        age = age,
        mortality.rate = as.numeric(q),
        random.number = as.numeric(u),
        sum.assured = phA$sum.assured[i],
        stringsAsFactors = FALSE
      ))
    }
  }
  
  cat("Part D – Simulation complete for year", year, "\n")
  cat("Simulated deaths:", nrow(deaths), "\n")
  return(deaths)
}

# ==========================================================
# Function list in R 
# ==========================================================

list.available.functions <- function() {
  cat("Available functions:\n\n")
  cat("Part A:\n")
  cat("  detect.errors(raw_file, output_file, data_year)\n\n")
  
  cat("Part B:\n")
  cat("  add.member(...)\n")
  cat("  record.deaths(policy_numbers, year)\n")
  cat("  record.withdrawals(policy_numbers, year)\n")
  cat("  check.end.of.term(year)\n\n")
  
  cat("Part C:\n")
  cat("  summarise.premiums(year)\n")
  cat("  summarise.death.benefits(year)\n")
  cat("  policy.summary(policy_number, year, rate)\n\n")
  
  cat("Part D:\n")
  cat("  simulate.deaths(year, seed = NULL)\n\n")
  
  invisible(TRUE)
}
